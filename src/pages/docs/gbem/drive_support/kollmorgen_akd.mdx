---
title: Kollmorgen AKD
sort: 10
---

import { Image } from "../../../../framework/components/Image"
import { Rate, Row, Col, Card, Alert } from 'antd';
import {YoutubeEmbed} from "../../../../framework/components/Video"
import {GitHubLink} from "../../../../framework/components/GitHubLink";
import {PdoCard} from "../../../../framework/components/PdoCard";
import {SdoCard} from "../../../../framework/components/SdoCard";

# Kollmorgen AKD

<GitHubLink title={"Drive interface code"} repo={"gbem"} directory={"/libs/kollmorgen"}/>

<GitHubLink title={"Example machine configuration"} repo={"gbem"} directory={"/libs/machine_map/src"} file={"single_akd.c"} />


## Introduction

This short guide reviews the Kollmorgen AKD range of drives and discusses how to get them working with GBEM.

import kollmorgen_akd_product_shot from "./kollmorgen_akd_product_shot.png?glowsite"

<Image meta={kollmorgen_akd_product_shot} alt="Kollmorgen AKD product" maxWidth={600}  />


## Overview of the AKD drive range

Introduced to the market in 2010 the AKD drive was amongst the first wave of EtherCAT drives and has been widely used in differing applications.

The product range spreads from the AKD-x00306, 1.1kW single phase drive to the AKD-x04807, 32kW three phase model. Recently introduced is the AKD2G  models. AKD2G model range includes dual axis in a single chassis models and have all have a whizzy TFT screen on the drive which is actually a step on on from the AKD model's dual 7 segment display in terms of usefullness.

There are lots of feedback options include the Kollmorgen specific SFD and EnData and HIPERFACE and resolver.

AKD drives have 11 digital and 2 analog IOs and they are opto-isolated. AKD2G have 16 IO. 

The motor range is excellent and includes:

* DDR motors (https://www.kollmorgen.com/en-us/products/motors/direct-drive/direct-drive-linear-and-rotary-motors/) 
* Frameless motors
* Linear motors and linear actuators
* Stainless steel, washable, food grade

They all support a STO with the AKD2G models supporting dual channel.

Cables are field constructible with connectors available.

In terms of motors, the standard AKD motor is the AKM. Recently introduced is the AKM2G . The AKM2G range includes motors with low-voltage windings (24 to 96 volts) and singel cable options.

For the purpose of this review we used a standard AKD-x00306 drive with an AKM motor.

## Our ratings for the Kollmorgen AKD (not AKD2G)

<div style={{margin:"20px"}}>
    <Row>
        <Col span={6}>Overall rating</Col>
        <Col span={4}><Rate disabled defaultValue={3}/></Col>
        <Col span={14}>Overall very good but showing their age</Col>
    </Row>

    <Row>
        <Col span={6}>Drive configuration software rating</Col>
        <Col span={4}><Rate disabled defaultValue={5}/></Col>
        <Col span={14}>Kollmorgen studio is pretty damn good</Col>
    </Row>
    <Row>
        <Col span={6}>Drive features rating</Col>
        <Col span={4}><Rate disabled defaultValue={3}/></Col>
        <Col span={14}>Does the basics but low on fancy features - bit outdated</Col>
    </Row>
    <Row>
        <Col span={6}>Motors rating</Col>
        <Col span={4}><Rate disabled defaultValue={4}/></Col>
        <Col span={14}></Col>
    </Row>
    <Row>
        <Col span={6}>Gearbox option</Col>
        <Col span={4}><Rate disabled defaultValue={5}/></Col>
        <Col span={14}>Excellent</Col>
    </Row>
    <Row>
        <Col span={6}>Price</Col>
        <Col span={4}><Rate disabled defaultValue={3}/></Col>
        <Col span={14}>Roughly â‚¬800 for 3A drive excluding cables and motor</Col>
    </Row>
</div>



## Wiring up

1. Basic wiring
   1. X1 - 24V 0V and pin 3 (STO) to 24V
   2. X2 - connect motor (usually motor power cables are pre-wired with this connector)
   3. X10 - feedback connector (usually the motor encoder cable is pre-wired with this connector)
   4. X8 - pin 3 0V and pin 4 24V (hardware enable)
   5. X3 AC power (L1 and L2 with L3 unconnected for single phase). This is important as wiring L1, L2, L3 connectors varies between manufacturers. 
2. Install Kollmorgen workbench
3. Set the S1 and S2 rotary switches to 0 for DHCP. For static is S1 = 3 and S2 = 5 you get a 192.168.0.35 IP address
4. Connect X11 port on side of drive to your network or PC
5. Set the PC IP address to match drives if using statics
6. Press the B1 on the side of the drive (a little button you need a paperclip to press) to confirm P address - the IP address flashes up on LED display (you may need to video it on your phone to capture it!)
7. Run the Kollmorgen workbench software which should auto find drive or there are buttons to press in the UI to trigger a scan
8. In the software, you can set the service IP address to a new IP address
9. Give the drive a friendly name - this is pretty essential if you are working with lots of drives with different parameters 
10. Update the drive's firmware. This is essential for working with GBEM as a couple of bugs in the Kollmorgen firmware cause issues and there are later firmware features we need.
11. Jog drive in the Kollmorgen software to test that things are golden

## Drive commissioning software

Kollmorgen workbench

Free

Wuite good

## Startup SDOs

<SdoCard name={"Interpolation time index"} index={"0x60C"} subindex={"0x2"} value={"3"} notes={"a -3 exponent to the interpolation time period"}/>
<SdoCard name={"Interpolation time period"} index={"0x60C2"} subindex={"0x1"} value={"MAP_CYCLE_TIME"} notes={"Set to our cycle time (1ms, 2ms, 4ms"}/>

Subindex 2, known as the interpolation time index, defines the power of ten of the time value
(e.g. -3 means 10-3 or milliseconds) while subindex 1, known as interpolation time units, gives the number of units (e.g. 4 means 4 units).
You can run a 2 ms cycle using various combinations. For example,
* Index = -3, Units = 2 or
* Index = -4, Units = 20 etc.

<SdoCard name={"Activate fieldbus synchronisation"} index={"0x36E6"} subindex={"0x0"} value={"1"} />
<SdoCard name={"Synchronization supervision of the EtherCAT fieldbus"} index={"0x36E8"} subindex={"0x0"} value={"1"} notes={"This will error the drive if the sync. fails - turn off when commissioning"}/>
<SdoCard name={"Scaling is done using special DS402 - objects (independent on units)"} index={"0x36E9"} subindex={"0x0"} value={"set bit 4"}/>
<SdoCard name={"drv.opmode"} index={"0x35B4"} subindex={"0x0"} value={"2"} />
<SdoCard name={"Motor revolutions"} index={"0x6091"} subindex={"0x1"} value={"1"} />
<SdoCard name={"Shaft revolutions"} index={"0x6091"} subindex={"0x2"} value={"1"} />
<SdoCard name={"Feed"} index={"0x6092"} subindex={"0x1"} value={"655,360"}/>
<SdoCard name={"shaft revolutions"} index={"0x6092"} subindex={"0x2"} value={"1"} />


## PDO mapping

The PDO mapping is straight-forward. We use a pre-defined set of maps.

**0x1b26** This predefined PDO mapping is the ds402 scaled actpos version (later AZD firmware only). It includes:

 * status word (2 bytes), Position actual internal value ( 4 bytes),torque actual value (2bytes),digital inputs (4 bytes),
 *  analog input value (2 bytes), follow error actual value (2 bytes)

**0x1724** Target position for cyclic synchronous position mode (4 bytes - DINT), Control word (2byte), Torque feed forward (2 bytes)

So in the code, we create two arrays containing the map we want to apply.

```c
uint16_t map_SM3_index_of_assigned_PDO_akd[ECM_MAX_PDO_MAPPING_ENTRIES] = {
        0x1b26};
uint16_t map_SM2_index_of_assigned_PDO_akd[ECM_MAX_PDO_MAPPING_ENTRIES] = {
        0x1724};
```

The code used to apply these can be found in the library.

## Default netscan

```c
```

## Netscan post PDO mapping

After applying our PDO mapping this is the netscan output:

```c
```


## Writing the driver code


The driver code is located at `/libs/kollmorgen/kollmorgen.c/h`.



### MOO

Reading modes-of-operation must be done with an SDO read.

```c
if (!ec_sdo_read_int8(map_drive_to_slave[drive], AKD_MOO_GET_SDO_INDEX, AKD_MOO_GET_SDO_SUB_INDEX, &ib8))
```

### Follow-error

```c
    if (ec_pdo_get_input_uint32(map_drive_to_slave[drive], AKD_FOLLOWERROR_ACTVAL_PDO_INDEX) > AKD_FOLLOW_ERROR_TOLLERANCE){
        return true;
    }
    return false;
```

## Remote bit

remote bit is provided is the status word.

Read with: `drive_stat_wrd = ec_get_stat_wrd_akd(drive)` and check with `(BIT_CHECK(drive_stat_wrd, CIA_REMOTE_BIT_NUM))`

## actpos
Simple read from PDO:

```c
int32_t ec_get_actpos_wrd_akd(const uint16_t drive) {
return ec_pdo_get_input_int32(map_drive_to_slave[drive], AKD_ACTPOS_PDO_INDEX);
}
```

## Testing

<YoutubeEmbed embedId="" />

## More information

<Alert message="Information" description="A more detailed guide to integrating this motor driver with the glowbuzzer toolkit is available to our customers - please contact us" type="info" showIcon style={{margin: '20px 0 20px 0'}} />