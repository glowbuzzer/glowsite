import {Tldr} from "../../../framework/components/Tldr"
import { Link } from "react-router-dom"
import {GlowsiteLink} from "../../../framework";


# {props.subtitle}
<Tldr>
    - Control single joints (motors)
    - Control multiple joints in master/slave configurations
    - Control multiple joints performing co-ordinated motion in 3D space
</Tldr>

## Introduction

&gbc has a sophisticated motion control at its heart.

With &gbc we can control:

* Single joint motion control - for example, move a joint to a position, move a joint at velocity
* Multiple joints in master/slave - for example, move joint 1 at twice the velocity of joint 2
* Multiple joints in co-ordinated motion in 3D space - for example, move a tool through 3D space along a line or arc

Within &gbc motion primitives exist. These are fundamental ways to move joints and kinematics configurations: for example `MoveJointsAtVelocity` and `moveVectorAtVelocity`.

## Interacting with the &gbc motion primitives

Motion primitives are interacted with within &gbt in different ways. Using Tiles, through the Hooks API and through the Websockets API.

### **Tiles** - you can add pre-built tiles like `JogTile`, `GCodeTile` etc. to your React project which give you an "out of the box" way to invoke motion primitives.

The `JogTile` allows you to move Joints and Kinematics Configurations either to a specific position or be "jogged" manually to a position. See <GlowsiteLink to="/docs/gbr/tiles/JogTile">JogTile</GlowsiteLink> for more information.

The `GCodeTile` allows you to stream gcode containing different movement instructions to &gbc. See <GlowsiteLink to="/docs/gbr/tiles/GCodeTile">GCodeTile</GlowsiteLink> for more information.

"Under the covers" these tiles use the APIs described in the next sections to perform motion/.

### **Using the Hooks API** - `SoloActivity`, `useGcode`

Programmatically, the easiest route to invoke motion primitive from a React Application is to use the `SoloActivityApi`. See <GlowsiteLink to="/docs/types/SoloActivityApi">SoloActivityApi</GlowsiteLink> for more information.

The solo activity API is instantiated against a kinematics configuration and has exclusive access to the motion of that KC.

You can also stream commands using &gcode. For more information, see [Streamed activities](/docs/gbr/gcode).

### **Using the &gbc Websockets interface itself** - Start task, send solo activity, stream

You can also invoke motion primitives with the Websockets interface itself.

The three possible ways to invoke motion primitives with Webscokets messages are:

1. Send a SoloActivity
1. Stream an Activity
1. Start a task (containing activities) running

#### Send a SoloActivity

Instead of using the UseSoloActivity hooks API, you can compose and send a Websockets message.

The message would look like:

```json{
    command: {
        soloActivity: {
            0: {
                command: {
                    tag: 42,
                    activityType: 3,
                    moveJoints: {
                        jointPositionArray: [...]
                    }
                }
            }
        }
    }
}
```

This message will invoke a `moveJoints` against one or more of the joints in the `jointPositionArray`.

The `tag` is a unique number that would allow the user of the API to track different moves issued.

The behaviour of the SoloActvity API is such that if you were to issue another Activity whilst the first is running, the first Activity would be cancelled and second then run.

The SoloActivity has a one-to-one mapping with a kinematics configuration and this mapping needs to be in your config file. See XXXX

See <GlowsiteLink to="/docs/types/SoloActivityCommand">SoloActivityCommand</GlowsiteLink> for more information (this is union of `ActivityStreamItem`).

#### Stream an Activity

You can also stream an activity using a websockets message.

```json{
    stream: {
        soloActivity: {
            0: {
                command: {
                    tag: 42,
                    activityType: 3,
                    moveJoints: {
                        jointPositionArray: [...]
                    }
                }
            }
        }
    }
}
```

See <GlowsiteLink to="/docs/types/StreamCommand">StreamCommand</GlowsiteLink> for how to start and stop a stream with the Websockets API.

The key differences between using the SoloActivity API and Streamed API are:

1. Streamed activities are queued whereas each SoloActivity has a single "slot" to hold the current Activity
1. Streamed motions can be blended (where one motion is blended into the next avoiding the machine stopping at junctions between motions) whereas SoloActivities can not be blended
1. You can await the completion of a SoloActivity so that your React control program can continue its flow when completed whereas with streamed activities the next in the queue executed as soon as the first is finished

#### Start a task

Finally, you can start a task with a Websocket message. Tasks must be pre-configured in the (JSON) config file with the activities you want to run when you start the task.

For example for a `MoveLine` activity you would start by creating a <GlowsiteLink to="/docs/types/LinesConfig">LinesConfig</GlowsiteLink> item for the line you want to move along.

Then, in the <GlowsiteLink to="/docs/types/MoveLineConfig">MoveLineConfig</GlowsiteLink> section of your config file you would reference the index of the line object you created together with the index of the kinematicsConfiguration you want to move and the index of the moveParameters (velocity of the move etc.) that you want to use.

Then you would create a task <GlowsiteLink to="/docs/types/TaskConfig">TaskConfig</GlowsiteLink> referencing the index of the Activity you created (`firstActivityIndex`).

The task would be started with <GlowsiteLink to="/docs/types/TaskCommand">TaskCommand message</GlowsiteLink>.

The task would then execute the activity that it contains then the task would terminate.

## Single joint motion control primitives

This is the most basic form of motion control. It allows you to control a joint in the following ways:

* Move to a position specified either relative to current position or absolutely - `moveJoints` - see <GlowsiteLink to="/docs/types/MoveJointsStream">moveJoints</GlowsiteLink>
* Move at velocity when the joint ramps up speed to a given velocity - `moveJointsAtVelocity` <GlowsiteLink to = "/docs/types/MoveJointsAtVelocityStream">MoveJointsAtVelocity</GlowsiteLink>

## Multiple joints in co-ordinated motion in 3D space

Moving in 3D cartesian

* Move in an arc - `moveArc` - see <GlowsiteLink to = "/docs/types/MoveArcStream">moveArc</GlowsiteLink>

* Move along a linear path to the target position - `moveLine` - see <GlowsiteLink to = "/docs/types/MoveLineStream">moveLine</GlowsiteLink>

* Move in a vector (straight line) along the given vector. The velocity of the motion can be controlled using moveParams. `moveVectorAtVelocity` - see <GlowsiteLink to = "/docs/types/MoveVectorAtVelocityStream">moveVectorAtVelocity</GlowsiteLink>

* Move to the target position in joint space -`moveToPosition` - see <GlowsiteLink to = "/docs/types/MoveToPositionStream">moveToPosition</GlowsiteLink>

## Cartesian space vs. Joint space

With robots and other machines with complex kinematics configurations, there is a distinction between joint space and cartesian space. Put simply, joint space is joint angles and cartesian space is x, y, z and orientation.

For a machine with cartesian kinematics (XYZ), essentially, joint space is the same as cartesian space.

For moves planned in cartesian space with cartesian space targets:

* `MoveArc`
* `MoveLine`

Moves planned in joint space with cartesian space target:

* `MoveToPosition`

Moves planning in joint space with joint space target

* `MoveJoints`
* `MoveJointsAtVelocity`

