import {Tldr} from "../../../framework/components/Tldr"
import { Link } from "react-router-dom"

# {props.subtitle}

<Tldr>
    - &gbc is configured with a set of JSON files
    - These configure things like:
        - Number of joints in your machine
        - amax, jmax, vmax for the joints
        - Bus cycle time
</Tldr>

## Introduction

&gbc is configured with a set of JSON files.

These files are placed on the filesystem in the same directory as the &gbc executable and are read during the start-up process.

If the files are not present, &gbc uses a default configuration "baked into" the executable.

The configuration files cover:

* The machine configuration - configuration for the joints and IO that make up the machine
* Fieldbus layout - the layout of the fieldbus (shared memory) (advanced users only)
* Tasks definitions - definitions of tasks that are to be run on &gbc

The`default.json` file includes a number of other JSON files that together define the configuration of the machine. These files (with the exception of fieldbus.json) need to be edited to suit your machine.

```json
"$include machine": "machine_xxx.json",
"$include fieldbus": "fieldbus.json",
"$include task": "tasks.json",
```

## `machine_xxx.json`

### Introduction

This is the most important file and defines the machine that &gbc is interacting with.

The sections of this document correspond to Config sections of the schema.

### machine

`machine` maps to `MachineConfig` - see <Link to="/docs/gbc/schema/MachineConfig">here</Link>

Bus cycle time needs to be 1, 2, 4 and must match the bus cycle time in &gbem or &gbsm and is needed to ensure the calculated trajectories match the actual cycle at which they are sent to motors

```json
"machine": {
    "default": {
    "busCycleTime": 4
    }
}
```

### stream

`stream` maps to `StreamConfig` - see <Link to="/docs/gbc/schema/StreamConfig">here</Link>

```json
"stream": {
    "default": {
    }
  },
```

### joint

`joint` maps to `JointConfig` - see <Link to="/docs/gbc/schema/JointConfig">here</Link>

Joints correspond to the axes or motors on your machine and in this section we define their kinematic limits vmax, amax and jmax.

We also need to scale the position sent to the joints - see [scaling](scaling.md) for more details on how to set the scale factor.

These need to correspond to the joints defined in &gbem or &gbsm

````json
"joint": {
    "0": {
    	"vmax": 200,
    	"amax": 4000,
    	"jmax": 80000,
    	"scale": 133.33333333
    },
    "1": {
      	"vmax": 200,
      	"amax": 4000,
      	"jmax": 80000,
      	"scale": 266.66666666
    },
    "2": {
      	"vmax": 200,
      	"amax": 4000,
      	"jmax": 80000,
      	"scale": 1000.0
    }
  }
````



### jog

`jog` maps to `JogConfig` - see <Link to="/docs/gbc/schema/JogConfig">here</Link>

```json
"jog": {
    "0": {
      	"kinematicsConfigurationIndex": 0
    }
  },
````

### kinematicsConfiguration

`kinematicsConfiguration` maps to `KinematicsConfigurationConfig` - see <Link to="/docs/gbc/schema/KinematicsConfigurationConfig">here</Link>

````json
"kinematicsConfiguration": {
    "default": {
      "frameIndex": 0,
      "participatingJoints": [
        0,
        1,
        2
      ],
      "participatingJointsCount": 3,
      "kinematicsParameters": {
        "kinematicsConfigurationType": 3,
        "xExtents": [
          -100,
          100
        ],
        "yExtents": [
          -100,
          100
        ],
        "zExtents": [
          -100,
          100
        ],
        "cartesianParameters": {
          "linearVmax": 20,
          "linearAmax": 400,
          "linearJmax": 8000,
          "tcpRotationalVmax": 100,
          "tcpRotationalAmax": 1000,
          "tcpRotationalJmax": 10000
        },
        "kinChainParams": {
          "numRows": 6,
          "numCols": 5,
          "data": [
            -90,
            0,
            0,
            0,
            0,
            0,
            0,
            -90,
            225,
            0,
            90,
            0,
            90,
            0,
            35,
            -90,
            0,
            0,
            0,
            225,
            90,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            65
          ]
        }
      }
    }
  },


````



### din, dout, ain, aout, iin, iout

These map to:

* din - DinConfig - see <Link to="/docs/gbc/schema/DinConfig">here</Link>
* dout - DoutConfig - see <Link to="/docs/gbc/schema/DoutConfig">here</Link>
* ain - AinConfig - see <Link to="/docs/gbc/schema/AinConfig">here</Link>
* aout - AoutConfig - see <Link to="/docs/gbc/schema/AoutConfig">here</Link>
* iin - IinConfig - see <Link to="/docs/gbc/schema/IinConfig">here</Link>
* iout - IoutConfig - see <Link to="/docs/gbc/schema/IoutConfig">here</Link>



````json
  "din": {
    "0": {
      "inverted": 1
    },
    "1": {
      "inverted": 0
    },
    "2": {
      "inverted": 0
    },
    "3": {
      "inverted": 0
    }
  },
  "dout": {
    "0": {
      "inverted": 0
    },
    "1": {
      "inverted": 0
    },
    "2": {
      "inverted": 0
    },
    "3": {
      "inverted": 0
    },
    "4": {
      "inverted": 0
    },
    "5": {
      "inverted": 0
    },
    "6": {
      "inverted": 0
    },
    "7": {
      "inverted": 0
    },
    "8": {
      "inverted": 0
    },
    "9": {
      "inverted": 0
    }
  },
  "ain": {
    "0": {
    }
  },
  "aout": {
    "0": {
    }
  },
  "iin": {
    "0": {
    }
  },
  "iout": {
    "0": {
    }
  }
}
````

## `fieldbus.json`

This defines the structure of the fieldbus and is usually not to be altered.

```json
{
  "fieldbus": {
    "0": {
      "jointCount": 10,
      "RxPdo": {
        "machineStatusWordOffset": 0,
        "activeFaultOffset": 4,
        "faultHistoryOffset": 8,
        "heartbeatOffset": 12,
        "jointStatuswordOffset": 16,
        "jointActualPositionOffset": 36,
        "jointActualVelocityOffset": 76,
        "jointActualTorqueOffset": 116,
        "digitalOffset": 156,
        "digitalCount": 8,
        "analogOffset": 164,
        "analogCount": 6,
        "integerOffset": 188,
        "integerCount": 2
      },
      "TxPdo": {
        "machineControlWordOffset": 0,
        "gbcControlWordOffset": 4,
        "hlcControlWordOffset": 8,
        "heartbeatOffset": 12,
        "jointControlwordOffset": 16,
        "jointSetPositionOffset": 36,
        "jointSetVelocityOffset": 76,
        "jointSetTorqueOffset": 116,
        "digitalOffset": 156,
        "digitalCount": 10,
        "analogOffset": 164,
        "analogCount": 6,
        "integerOffset": 188,
        "integerCount": 2
      }
    }
  }

```

## `tasks.json`



```json
{
  "task": {
    "move joint": {
      "activity1": {
        "activityType": 4
      }
    },
    "move line": {
      "activity1": {
        "activityType": 1
      }
    },
    "move at velocity": {
      "activity1": {
        "activityType": 0,
        "skipToNextTriggerIndex": 1
      }
    }
  }
}
```

## GBC options and running

To run GBC, usually `./GBC` is enough.

You can optionally specify command line arguments of:

`-pPORT` and `-sSHARED_MEMORY_NAME` and `gSIGNAL` and `-lLOG_LVL` and `-dLOG_CAT` and `-v`.

Usually the default HTTP server `PORT` of 9001 and `SHARED_MEMORY_NAME` of "gbc_shared_mem" and `SIGNAL` of 29 (SIG I/O POSSIBLE) will be used but you can vary these if needed.

`LOG_LVEL` sets logging level. The following log levels (in order of increasing verbosity) are:

* LOG_LVL_FATAL=0
* LOG_LVL_ERROR=1
* LOG_LVL_WARNING=2
* LOG_LVL_INFO=3
* LOG_LVL_DEBUG=4
* LOG_LVL_TRACE=5

`LOG_CAT` sets the category of logs outputted. The following categories are supported:

    * `WS_LOG` - Websockets log enable
    * `JS_LOG` - JavaScript log enable
    * `JS_MEM_LOG` - JavaScript memory management log enable
    * `ACTIVITY_LOG` - Activity log enable
    * `OTG_LOG` - Trajectory planner log enable
    * `HTTP_LOG` - HTTP server log enable
    * `STARTUP_LOG` - GBC startup log enable
    * `STACK_LOG` - stack log enable
    * `TASK_LOG` - task log enable
    * `STATE_LOG` - state log enable (the state of the connection to GBR and PLC)
    * `ACTIVITY_LOG` - activity log enable
    * `TELEMETRY_LOG` - telemetry log enable
    * `FIELDBUS_LOG` - fieldbus log enable
    * `FRAMES_LOG` - frames log enable
    * `KC_LOG` - kinematics configuration log enable
    * `STREAM_LOG` - stream log enable
    * `MACHINE_LOG` - machine log enable
    * `ALL_LOG` - All logging categories enabled. This creates a logging avalanche so be careful




To use &gbc to control actual machines, requires that the version of Linux used has the preempt patch installed.

This is not needed to use &gbc in simulation mode.

Similarly, &gbc will not run in real-time on virtual machines (on Windows) but these can be used in simulation mode for development.

Once run, &gbc will output to the console, various logging information about what it is up to. In the case you are having issues, picking carefully through this output is recommended as a good starting point to fault diagnosis.

The first output should look something like this.

```text
[INFO  ] GBC: **************************************************************************
[INFO  ] GBC: ***                         Starting GB Control                        ***
[INFO  ] GBC: **************************************************************************
[WARN  ] GBC: No valid port was specified on the command line. Will use the default [9001]
[WARN  ] GBC: No valid signal was specified on the command line. Will use the default [29]
[WARN  ] GBC: No valid shared memory name was specified on the command line. Will use the default [gbc_shared_memory]
[INFO  ] GBC: Software project name [GBC]
[INFO  ] GBC: Software project version [0.0.1]
[INFO  ] GBC: Release Git Tag [0.0.0]
```

