import {Avatar, Col, Divider, List, Row} from 'antd'
import {Tldr} from "../../framework/components/Tldr"
import {ApiOutlined, FieldBinaryOutlined,DesktopOutlined, ApartmentOutlined, StepForwardOutlined, DownloadOutlined, DashboardOutlined, EyeOutlined} from "@ant-design/icons"
import TiersImage1 from './tiers-GBEM.svg'
import TiersImage2 from './tiers-GBSM.svg'


# {props.subtitle}

<Tldr>
- Multiple components in the toolkit
- Layer 1 (&gbr) - React components
- Layer 2 (&gbc)- Real-time control
- Layer 3 (&gbem/&gbsm)- Drives & IO interface
</Tldr>

The &gbt is structured as three layers.
Each layer is a separate software component in the &gbt.

**LAYER1**

: The front-end React components used to build the user interface and machine control logic

**LAYER2**

: The real-time core control

**LAYER3**

: The interface to drives and IO

# Integrating with a fieldbus

When you want to integrate with EtherCAT drives and IO, you use &gbem which is an EtherCAT master. This talks to &gbc the real-time control and to the EtherCAT network itself.

<img src={TiersImage1} alt="GBEM tiers"/>

# Integrating with a motor driver ICs

When you want to integrate with motor driver ICs (usually in an embedded environment) you used &gbsm which talks over SPI to common motor driver ICs.

<img src={TiersImage2} alt="GBSM tiers"/>

## LAYER 1 - &gbrl

We supply a comprehensive set of components to perform the fundamental machine control functions. Some examples of these components include:

<List bordered style={{width: '700px', margin: '20px'}}>
    <List.Item>
        <List.Item.Meta
            title="Connect to a machine"
            description="Establish a websockets connection to GBC"
            avatar={<Avatar
                icon={<ApiOutlined/>}
                size={"large"}
                style={{backgroundColor: "#f0f0f0", color: "black"}}
            />}
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<FieldBinaryOutlined/>} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="Manage digital and analogue inputs and outputs"
            description="Control and monitor the state of digital and analog inputs and outputs on the machine"
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<ApartmentOutlined/>} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="Manage the machine's state (switched on, faults)"
            description="The state of the machine is a superimposed state of underlying drives and sub-systems"
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<StepForwardOutlined />} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="Make a machine move - jogging"
            description="Jogging a machine is a basic machine function to move axes in concert or individually"
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<DashboardOutlined />} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="See the machineâ€™s position (DRO)"
            description="Machines with motors have a position. This can be the position of the motors themselves or the end-effector/tool if the motors act in concert"
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<DownloadOutlined />} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="Send gcode to a machine"
            description="gcode is an easy to use way to control machines. We supply the components to interpret and transmit this gcode to a machine"
        />
    </List.Item>
    <List.Item>
        <List.Item.Meta
            avatar={<Avatar
                icon={<EyeOutlined />} size={"large"} style={{backgroundColor: "#f0f0f0", color: "black"}}/>}
            title="See the path on which a machine moves"
            description="Plot the path the machine's end-effector or tool follows"
        />
    </List.Item>
</List>



These components are all published under an open - source license agreement and are fully customisable.You can also, of course, tap in the vast ecosystem of components & code available in the wider React / JavaScript ecosystem.When FE components need the machine to do something, they send high - level commands to the machine control over a WebSocket interface.They also receive messages containing the state of the machine over this connection.


## LAYER 2 - &gbcl

This is the only closed source component of the &gbt.

&gbc takes high level machine commands from the FE over a WebSocket connection and processes them into a form that the fieldbus can understand, namely a process image(output - PI) detailing the state of all outputs updated on a millisecond cycle time.

In reverse, the input - PI is updated from the state of the fieldbus and sent back to the FE in the form of high level WebSocket messages.

When running on a Linux platform, the process image is available via a shared memory interface(or on embedded platform a dual port memory(Q)SPI interface) for use by whatever process is responsible for reading and writing from the fieldbus or to motors and IO.

&gbc calculates the trajectories for any motion commands issued and performs the forward and inverse kinematics for different machine configurations.

## LAYER 3 - &gbeml & &gbsml

The process image generated by &gbc needs to be written to and read from drives & IO.

We provide a number of options to enable this:

All are available either on Linux or embedded microcontroller.

* Option 1 - When communicating with EtherCAT drives and IO, we provide &gbem, an EtherCAT master based on the SOEM open - source EtherCAT master stack
* Option 2 - If you want to integrate &gbt into an different EtherCAT master, we provide an interface layer to integrate with common EtherCAT slave ICs (for example Microchip's LAN9252/3) to provide an EtherCAT slave interface.
* Option 3 - If you want to  integrate &gbt into a non-EtherCAT network (for example, Ethernert/IP, Profinet), we provide an interface layer to the Hilscher netX chipset. We also have integrations with different Open Source Ethernet fieldbus masters.
* Option 4 - If you want to communicate with stepper/servo/BLDC motors through motor driver ICs, we provide &gbsm to communciate with chips over SPI (our reference design for this uses the Trinamic chip set)


